# Frontend_на_Vite

## Frontend_на_Vite

**Версия:** 1.0
**Дата последнего обновления:** 26.10.2023
**Автор:** Дмитрий Петров, Frontend-разработчик

**Введение**

Этот документ описывает архитектуру и разработку frontend-части платформы Butterboard, построенной на базе Vite. Vite обеспечивает быструю разработку, горячую перезагрузку и оптимизированную сборку, что критически важно для нашей платформы, где скорость и удобство для пользователей - приоритет.  Мы используем Vue.js в качестве основного фреймворка для интерактивного пользовательского интерфейса.  В данном разделе описаны используемые технологии, структура проекта, процесс сборки, а также рекомендации по разработке новых функций и интеграции.

**Технологический стек**

*   **Язык:** TypeScript
*   **Фреймворк:** Vue.js 3
*   **Сборщик:** Vite
*   **UI-библиотека:** Vuetify 3 (для компонентов, отвечающих за визуальный стиль и UI)
*   **Управление состоянием:** Pinia (опционально, для более сложных приложений)
*   **Тестирование:** Jest, Vitest, Cypress (для E2E-тестирования)
*   **Система сборки и деплоймента:**  Nginx (для production)
*   **Git:**  GitHub (для контроля версий)

**Структура проекта**

Проект организован следующей структурой:

```
butterboard-frontend/
├── public/              # Статические файлы (изображения, шрифты и т.д.)
├── src/                # Основной код приложения
│   ├── components/      # Vue-компоненты
│   │   ├── Button/
│   │   ├── Input/
│   │   └── ...
│   ├── composables/     # Vue composables (для переиспользуемого кода)
│   ├── layouts/         # Шаблоны страниц
│   │   ├── MainLayout.vue
│   │   └── ...
│   ├── router/          # Конфигурация роутера
│   ├── services/        # Сервисы для взаимодействия с backend
│   ├── stores/          # Pinia stores (если используется)
│   ├── App.vue          # Главный компонент приложения
│   ├── main.ts          # Точка входа приложения
│   └── utils/          # Вспомогательные функции
├── vite.config.ts      # Конфигурация Vite
├── tsconfig.json       # Конфигурация TypeScript
├── .eslintrc.js        # Конфигурация ESLint
└── ...
```

**Процесс сборки**

1.  **Установка зависимостей:**  `npm install` или `yarn install`
2.  **Запуск сервера разработки:** `npm run dev` или `yarn dev` (обычно на порту 3000)
3.  **Сборка для production:** `npm run build` или `yarn build` (генерирует оптимизированные файлы в папке `dist/`)

**Рекомендации по разработке**

*   **Использование Vuetify:**  Используйте Vuetify для создания UI-компонентов.  Это значительно ускорит разработку и обеспечит консистентный внешний вид.
*   **Компоненты:**  Разбивайте интерфейс на небольшие, переиспользуемые компоненты.
*   **Композуабелы:**  Выносите логику, которая может быть переиспользована между компонентами, в Vue composables. Это улучшает читаемость и тестируемость кода.
*   **Типизация:**  Используйте TypeScript для написания кода. Это поможет избежать ошибок и улучшит поддержку кода.
*   **Тестирование:**  Пишите unit-тесты для компонентов и E2E-тесты для проверки функциональности.
*   **Поддержка Accessibility:** Убедитесь, что ваш frontend доступен для пользователей с ограниченными возможностями.
*   **Оптимизация производительности:**  Используйте инструменты разработчика Chrome для анализа производительности и выявления узких мест.  Включите lazy loading изображений, используйте code splitting и другие техники.

**Примеры кода**

**Пример компонента `Button.vue`:**

```vue
<template>
  <v-btn :color="color" @click="onClick">
    {{ label }}
  </v-btn>
</template>

<script setup lang="ts">
import { defineProps, defineEmits } from 'vue';

interface Props {
  color: string;
  label: string;
}

const props = defineProps<Props>();
const emit = defineEmits(['click']);

const onClick = () => {
  emit('click');
};
</script>
```

**Пример использования в другом компоненте:**

```vue
<template>
  <Button color="primary" label="Click Me" @click="handleClick" />
</template>

<script setup lang="ts">
import Button from './components/Button.vue';

const handleClick = () => {
  console.log('Button clicked!');
};
</script>
```

**Контактная информация**

*   **Дмитрий Петров:** Frontend-разработчик,  dmitry.petrov@butterboard.online
*   **Антон Сидоров:**  Backend-разработчик (для вопросов, связанных с API), anton.sidorov@butterboard.online
*   **Олег Иванов (CEO, CTO):**  ol.ivanov@butterboard.online (для стратегических вопросов)
*   **Антон Титоренко (CMO, CEO):**  a.titarenko@butterboard.online (для вопросов, связанных с продуктом)
*   **HR Отдел:** hr@butterboard.online

**FAQ**

*   **Q: Какая версия Vue.js используется?**
    A:  Vue.js 3.
*   **Q: Как я могу посмотреть код в GitHub?**
    A:  [https://github.com/butterboard/frontend](https://github.com/butterboard/frontend)
*   **Q:  Как я могу внести изменения в код?**
    A:  Создайте feature branch в GitHub, внесите изменения и отправьте pull request.
*   **Q:  Как я могу отправить баг?**
    A:  Откройте issue в GitHub.  Обязательно укажите шаги для воспроизведения.
*   **Q:  Как происходит процесс деплоя?**
    A:  После сборки для production ( `npm run build`), файлы копируются на сервер Nginx.  Конфигурация Nginx находится в папке `/etc/nginx/sites-available/butterboard.online`.  Смена версий происходит вручную, с автоматическим rolling update.

Этот документ будет регулярно обновляться по мере развития проекта.  В случае возникновения вопросов обращайтесь к контактным лицам.
A: Откройте issue в GitHub. Обязательно укажите шаги для воспроизведения.
*   **Q: Как происходит процесс деплоя?**
    A: После сборки для production (`npm run build`), файлы копируются на сервер Nginx. Конфигурация Nginx находится в папке `/etc/nginx/sites-available/butterboard.online`. Смена версий происходит вручную, с автоматическим rolling update.

Этот документ будет регулярно обновляться по мере развития проекта. В случае возникновения вопросов обращайтесь к контактным лицам.

**Q: Кто является контактными лицами?**

    A: Контактными лицами по вопросам деплоя являются:
        * **Иван Иванов:**  ivan.ivanov@example.com - отвечает за мониторинг серверов и ручное обновление конфигурации.
        * **Мария Петрова:** maria.petrova@example.com - отвечает за сборку и проверку новых версий.
        * **GitHub Issue:**  Все вопросы, не требующие немедленного вмешательства вышеуказанных лиц, следует обсуждать в соответствующем issue в репозитории.  Пожалуйста, старайтесь максимально подробно описывать проблему и предоставлять все необходимые данные для воспроизведения.

**Q: Что такое rolling update?**

    A: Rolling update – это стратегия деплоя, при которой новые версии приложения разворачиваются на серверах постепенно, один сервер за другим.  Это позволяет минимизировать время простоя и избежать полной остановки сервиса во время обновления.  В нашем случае, после ручного обновления конфигурации Nginx, Nginx автоматически перезапускает только один сервер из группы, чтобы проверить новую версию.  Если все в порядке, процесс повторяется для остальных серверов в группе.  Подробная информация о конфигурации групп серверов и их перезапуске находится в файле `/etc/nginx/nginx.conf` в разделе `upstream`.

**Q: Какие инструменты используются для сборки?**

    A: Для сборки приложения используется пакет `npm` и скрипт `npm run build`. Этот скрипт включает в себя:
        * `webpack` - для сборки JavaScript.
        * `babel` - для преобразования современного JavaScript в код, совместимый со старыми браузерами.
        * `terser` - для минификации JavaScript.
        * `css-loader`, `style-loader`, `sass-loader` - для обработки CSS и Sass.
        * `html-webpack-plugin` - для генерации HTML файлов.
        * `copy-webpack-plugin` - для копирования статических ресурсов.

    Полный список зависимостей и конфигурация сборки описаны в файле `package.json` и `webpack.config.js`.

**Q: Где можно найти логи сервера?**

    A: Логи сервера Nginx находятся в папке `/var/log/nginx/`.  В частности, полезны следующие файлы:
        * `access.log`:  Содержит информацию о каждом запросе к серверу.
        * `error.log`:  Содержит информацию об ошибках, возникающих на сервере.

**Q: Как происходит мониторинг работоспособности приложения?**

    A: Мониторинг осуществляется с помощью сервиса [New Relic](https://newrelic.com/).  Он отслеживает метрики производительности, ошибки и другие важные показатели.  Также, мониторинг осуществляется вручную командой `pm2 status` для проверки статуса процессов.

Этот документ будет регулярно обновляться по мере развития проекта. В случае возникновения вопросов обращайтесь к контактным лицам.